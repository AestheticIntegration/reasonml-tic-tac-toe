// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

var of_string = Caml_format.caml_int_of_string;

function to_string(prim) {
  return String(prim);
}

function pp_print(prim) {
  return String(prim);
}

function of_int(s) {
  return s;
}

var Z = /* module */[
  /* of_string */of_string,
  /* to_string */to_string,
  /* pp_print */pp_print,
  /* of_int */of_int
];

function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function cons(x, y) {
  return /* :: */[
          x,
          y
        ];
}

function $$return(x) {
  return /* :: */[
          x,
          /* [] */0
        ];
}

function append(l1, l2) {
  if (l1) {
    return /* :: */[
            l1[0],
            append(l1[1], l2)
          ];
  } else {
    return l2;
  }
}

function rev(l) {
  if (l) {
    return append(rev(l[1]), /* :: */[
                l[0],
                /* [] */0
              ]);
  } else {
    return /* [] */0;
  }
}

function length(l) {
  if (l) {
    return Caml_format.caml_int_of_string("1") + length(l[1]) | 0;
  } else {
    return Caml_format.caml_int_of_string("0");
  }
}

function len_nonnegative(l) {
  return length(l) >= Caml_format.caml_int_of_string("0");
}

function len_zero_is_empty(x) {
  return length(x) === Caml_format.caml_int_of_string("0") === (x === /* [] */0);
}

function split(l) {
  if (l) {
    var match = l[0];
    var match$1 = split(l[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function map(f, l) {
  if (l) {
    return /* :: */[
            Curry._1(f, l[0]),
            map(f, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function for_all(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      if (Curry._1(f, l[0])) {
        _l = l[1];
        continue ;
      } else {
        return false;
      }
    } else {
      return true;
    }
  };
}

function exists(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      if (Curry._1(f, l[0])) {
        return true;
      } else {
        _l = l[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function fold_left(f, _acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      _param = param[1];
      _acc = Curry._2(f, acc, param[0]);
      continue ;
    } else {
      return acc;
    }
  };
}

function fold_right(f, base, l) {
  if (l) {
    return Curry._2(f, l[0], fold_right(f, base, l[1]));
  } else {
    return base;
  }
}

function filter(f, param) {
  if (param) {
    var x = param[0];
    var tail = filter(f, param[1]);
    if (Curry._1(f, x)) {
      return /* :: */[
              x,
              tail
            ];
    } else {
      return tail;
    }
  } else {
    return /* [] */0;
  }
}

function filter_map(f, param) {
  if (param) {
    var tail = filter_map(f, param[1]);
    var match = Curry._1(f, param[0]);
    if (match !== undefined) {
      return /* :: */[
              Js_primitive.valFromOption(match),
              tail
            ];
    } else {
      return tail;
    }
  } else {
    return /* [] */0;
  }
}

function flat_map(f, param) {
  if (param) {
    return append(Curry._1(f, param[0]), flat_map(f, param[1]));
  } else {
    return /* [] */0;
  }
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_equal(x, param[0])) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_equal(x, param[0][0])) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function nth(_n, _param) {
  while(true) {
    var param = _param;
    var n = _n;
    if (param) {
      if (n === Caml_format.caml_int_of_string("0")) {
        return Js_primitive.some(param[0]);
      } else {
        _param = param[1];
        _n = n - Caml_format.caml_int_of_string("1") | 0;
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (Caml_obj.caml_equal(x, match[0])) {
        return Js_primitive.some(match[1]);
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function take(n, param) {
  if (param && n > Caml_format.caml_int_of_string("0")) {
    return /* :: */[
            param[0],
            take(n - Caml_format.caml_int_of_string("1") | 0, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (l) {
      if (n <= Caml_format.caml_int_of_string("0")) {
        return l;
      } else {
        _l = l[1];
        _n = n - Caml_format.caml_int_of_string("1") | 0;
        continue ;
      }
    } else {
      return /* [] */0;
    }
  };
}

function $neg$neg(i, j) {
  if (i >= j) {
    return /* [] */0;
  } else {
    return /* :: */[
            i,
            $neg$neg(i + Caml_format.caml_int_of_string("1") | 0, j)
          ];
  }
}

function insert_sorted(leq, x, l) {
  if (l) {
    var y = l[0];
    if (Curry._2(leq, x, y)) {
      return /* :: */[
              x,
              l
            ];
    } else {
      return /* :: */[
              y,
              insert_sorted(leq, x, l[1])
            ];
    }
  } else {
    return /* :: */[
            x,
            /* [] */0
          ];
  }
}

function sort(leq, l) {
  return fold_left((function (acc, x) {
                return insert_sorted(leq, x, acc);
              }), /* [] */0, l);
}

function is_sorted(leq, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var tail = param[1];
      if (tail) {
        if (Curry._2(leq, param[0], tail[0])) {
          _param = tail;
          continue ;
        } else {
          return false;
        }
      } else {
        return true;
      }
    } else {
      return true;
    }
  };
}

var List$1 = /* module */[
  /* empty : [] */0,
  /* is_empty */is_empty,
  /* cons */cons,
  /* return */$$return,
  /* hd */List.hd,
  /* tl */List.tl,
  /* append */append,
  /* rev */rev,
  /* length */length,
  /* len_nonnegative */len_nonnegative,
  /* len_zero_is_empty */len_zero_is_empty,
  /* split */split,
  /* map */map,
  /* for_all */for_all,
  /* exists */exists,
  /* fold_left */fold_left,
  /* fold_right */fold_right,
  /* filter */filter,
  /* filter_map */filter_map,
  /* flat_map */flat_map,
  /* mem */mem,
  /* mem_assoc */mem_assoc,
  /* nth */nth,
  /* assoc */assoc,
  /* take */take,
  /* drop */drop,
  /* -- */$neg$neg,
  /* insert_sorted */insert_sorted,
  /* sort */sort,
  /* is_sorted */is_sorted
];

function $plus(prim, prim$1) {
  return prim + prim$1 | 0;
}

function $neg(prim, prim$1) {
  return prim - prim$1 | 0;
}

function $tilde$neg(prim) {
  return -prim | 0;
}

var $star = Caml_int32.imul;

var $slash = Caml_int32.div;

var mod = Caml_int32.mod_;

var $less = Caml_obj.caml_lessthan;

var $less$eq = Caml_obj.caml_lessequal;

var $great = Caml_obj.caml_greaterthan;

var $great$eq = Caml_obj.caml_greaterequal;

var min = Caml_obj.caml_min;

var max = Caml_obj.caml_max;

var equal = Caml_obj.caml_equal;

var compare = Caml_obj.caml_compare;

var Int = /* module */[
  /* + */$plus,
  /* - */$neg,
  /* ~- */$tilde$neg,
  /* * */$star,
  /* / */$slash,
  /* mod */mod,
  /* < */$less,
  /* <= */$less$eq,
  /* > */$great,
  /* >= */$great$eq,
  /* min */min,
  /* max */max,
  /* to_string */to_string,
  /* equal */equal,
  /* compare */compare,
  /* pp */pp_print,
  /* of_caml_int */of_int
];

function map$1(f, param) {
  if (param !== undefined) {
    return Js_primitive.some(Curry._1(f, Js_primitive.valFromOption(param)));
  }
  
}

function map_or($$default, f, param) {
  if (param !== undefined) {
    return Curry._1(f, Js_primitive.valFromOption(param));
  } else {
    return $$default;
  }
}

function is_some(param) {
  return param !== undefined;
}

function is_none(param) {
  return param === undefined;
}

function $$return$1(x) {
  return Js_primitive.some(x);
}

function $great$pipe$eq(x, f) {
  return map$1(f, x);
}

function $great$great$eq(o, f) {
  if (o !== undefined) {
    return Curry._1(f, Js_primitive.valFromOption(o));
  }
  
}

function or_(else_, a) {
  if (a !== undefined) {
    return a;
  } else {
    return else_;
  }
}

function $less$plus$great(a, b) {
  return or_(b, a);
}

function exists$1(p, param) {
  if (param !== undefined) {
    return Curry._1(p, Js_primitive.valFromOption(param));
  } else {
    return false;
  }
}

function for_all$1(p, param) {
  if (param !== undefined) {
    return Curry._1(p, Js_primitive.valFromOption(param));
  } else {
    return true;
  }
}

function get_or($$default, x) {
  if (x !== undefined) {
    return Js_primitive.valFromOption(x);
  } else {
    return $$default;
  }
}

function fold(f, acc, o) {
  if (o !== undefined) {
    return Curry._2(f, acc, Js_primitive.valFromOption(o));
  } else {
    return acc;
  }
}

var Option = /* module */[
  /* map */map$1,
  /* map_or */map_or,
  /* is_some */is_some,
  /* is_none */is_none,
  /* return */$$return$1,
  /* >|= */$great$pipe$eq,
  /* >>= */$great$great$eq,
  /* or_ */or_,
  /* <+> */$less$plus$great,
  /* exists */exists$1,
  /* for_all */for_all$1,
  /* get_or */get_or,
  /* fold */fold
];

function $$return$2(x) {
  return /* Ok */Block.__(0, [x]);
}

function fail(s) {
  return /* Error */Block.__(1, [s]);
}

function map$2(f, e) {
  if (e.tag) {
    return /* Error */Block.__(1, [e[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._1(f, e[0])]);
  }
}

function map_err(f, e) {
  if (e.tag) {
    return /* Error */Block.__(1, [Curry._1(f, e[0])]);
  } else {
    return e;
  }
}

function get_or$1(e, $$default) {
  if (e.tag) {
    return $$default;
  } else {
    return e[0];
  }
}

function map_or$1(f, e, $$default) {
  if (e.tag) {
    return $$default;
  } else {
    return Curry._1(f, e[0]);
  }
}

function $great$pipe$eq$1(e, f) {
  return map$2(f, e);
}

function flat_map$1(f, e) {
  if (e.tag) {
    return /* Error */Block.__(1, [e[0]]);
  } else {
    return Curry._1(f, e[0]);
  }
}

function $great$great$eq$1(e, f) {
  return flat_map$1(f, e);
}

function fold$1(ok, error, x) {
  if (x.tag) {
    return Curry._1(error, x[0]);
  } else {
    return Curry._1(ok, x[0]);
  }
}

function is_ok(param) {
  if (param.tag) {
    return false;
  } else {
    return true;
  }
}

function is_error(param) {
  if (param.tag) {
    return true;
  } else {
    return false;
  }
}

var Result = /* module */[
  /* return */$$return$2,
  /* fail */fail,
  /* map */map$2,
  /* map_err */map_err,
  /* get_or */get_or$1,
  /* map_or */map_or$1,
  /* >|= */$great$pipe$eq$1,
  /* flat_map */flat_map$1,
  /* >>= */$great$great$eq$1,
  /* fold */fold$1,
  /* is_ok */is_ok,
  /* is_error */is_error
];

function succ(x) {
  return x + Caml_format.caml_int_of_string("1") | 0;
}

function pred(x) {
  return x - Caml_format.caml_int_of_string("1") | 0;
}

function fst(param) {
  return param[0];
}

function snd(param) {
  return param[1];
}

function $percent$great(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

var $at = append;

exports.Z = Z;
exports.List = List$1;
exports.$at = $at;
exports.$neg$neg = $neg$neg;
exports.Int = Int;
exports.Option = Option;
exports.Result = Result;
exports.succ = succ;
exports.pred = pred;
exports.fst = fst;
exports.snd = snd;
exports.$percent$great = $percent$great;
/* No side effect */
